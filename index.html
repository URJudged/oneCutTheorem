<!DOCTYPE html>
<head>
<meta charset="utf-8">
<title>Interactive Gallery</title>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
<style>

body {
  overflow: hidden;
}
#displays {
  display: flex;
  position:absolute;
  top:0;
  left:0;
  bottom:0;
  right:0;
}
#c1c {
  position:relative;
  flex: 3;
  min-width: 200px;
  overflow: scroll;
}
#c1{
  width:100%;
  height:auto;
  max-width:800px;
}
#info {
  flex: 2;
  max-width:400px;
  min-width: 200px;
  height: 100%;
  overflow: scroll;
}
#infopanel {
  margin:20px;
}
.separator {
  margin-top:10px;
  margin-bottom:10px;
  border-bottom: 1px solid #eee;
}

.helptext {
  font-family:sans-serif;
  font-size:10px;
  font-style:italic;
  color:#888;
  background-color:rgba(255,255,255,0.9);
  text-align:center;
  position:absolute;
  top:10px;
  left:10px;
  right:10px;
  pointer-events:none;
}

.imgembed {
  width: 200px;
  max-width: 100%;
  margin:0 auto;
  display:block;
}

@media (max-width:500px){
  #displays{
    display:block;
    /*overflow:scroll;*/
  }
  #info{
    max-width:none;
    width:100%;
    height:auto;
    overflow:auto;
  }
  #c1c {
    overflow:auto;
  }
}
@media print {
  #info, .helptext {
    display:none;
  }
}

path.polygon {
  stroke: #000;
  fill: #eee;
  stroke-width: 5px;
}
path.polygon.bad {
  fill: transparent;
}
path.graph {
  stroke: #797;
  fill: transparent;
  stroke-width: 2px;
  pointer-events:none;
}
path.perp {
  stroke: #779;
  fill: transparent;
  stroke-width: 2px;
  pointer-events:none;
}
path.guard_vis {
  stroke: transparent;
  fill: rgba(255,0,0,0.3);
  pointer-events:none;
}

circle.polygon_v {
  fill: #000;
}
circle.graph_v {
  /*fill: #F00;*/
  stroke: #000;
  line-width:1px;
  pointer-events:none;
}

</style>
</head>
<body>

<script src="priority-queue.js"></script>
<script src="//d3js.org/d3.v3.min.js"></script>
<script type="text/javascript" src="numeric.js"></script>
<script src="simpler.js"></script>

<div id="displays">
  <div id="c1c">
    <div class="helptext">Drag vertices to deform polygon. Shift-drag an existing vertex to create a new vertex. Click on a vertex to remove it.</div>
    <svg id="c1" width="800" height="800" viewBox="0 0 800 800"></svg>
  </div>
  <div id="info"><div id="infopanel" class="panel panel-default">
    <div class="panel-body">
      <!-- <button id="resetbutton" class="btn btn-warning">Reset Hexagon</button> -->
      <!-- <div class="separator"></div> -->
      <h1>One-Cut Helper</h1>
      <h4>A project by <strong>Daniel Johnson</strong>, <strong>Judge Lee</strong>, and <strong>Jackson Warley</strong>.</h4>
      <p>The one-cut theorem, proved by Erik D. Demaine, Martin L. Demaine, and Anna Lubiw, statest that any plane graph of cuts can be formed by folding a sheet of paper and then making a single cut. This folding is based on the straight-skeleton of the plane graph.</p>

      <p>The straight skeleton is defined by continuously shifting the edges of the polygon inward and tracing the paths formed by the vertices. To enable this to be folding, perpendiculars are added to the graph. These perpendiculars start at vertices of the straight skeleton and then trace out lines perpendicular to the cut edges (the edges of the polygon).</p>

      <h2>How to Fold And Cut a Polygon:</h2>
      <ol>
      <li>Create your polygon on the left.</li>
      <li>Print out this page.</li>
      <li>Crease the mountain folds (denoted by dashed lines) and valley folds (denoted by dotted lines).</li>
      <li>Fold along the lines. The cut edges should all line up. If folding is difficult, it can be helpful to identify <em>corridors</em>, which are regions bounded by perpendiculars (denoted by something?). Each corridor should have a constant width, and will be foldable into a single fan-like column, called an <em>accordion</em>.</li>
      <li>Make your cut!</li>
      </ol>
    </div>
  </div></div>
</div>

<script>

var width = 800,
    height = 800;

// var polygon = [[300,300],[341,370],[322,411],[402,436],[296,437],[213,296],[450,170],[563,339],[511,326],[480,381],[433,307]];
// var polygon = [[300,300],[450, 170],[600, 310],[450, 450],[400, 290]];
// var polygon = [[300,300],[600, 300],[450, 450]];
var polygon = [[354.127197265625,461.0284118652344],[359.4438171386719,145.16644287109375],[777.576416015625,345.43707275390625],[284.9641571044922,688.3106689453125],[585.2542419433594,300.9234924316406],[485.18267822265625,286.2652282714844]];
// var polygon = [[354.127197265625,461.0284118652344],[359.4438171386719,145.16644287109375],[777.576416015625,345.43707275390625],[284.9641571044922,688.3106689453125],[485.18267822265625,286.2652282714844]];
var polygon_is_good = true;

var sskel = null;
var perps = null;

//////////////////////////

function dragmove(d,i) {
  // console.log("Drag");
  d[0] += d3.event.dx;
  d[1] += d3.event.dy;

  if(d[0]<0) d[0]=0;
  if(d[0]>width) d[0]=width;
  if(d[1]<0) d[1]=0;
  if(d[1]>height) d[1]=height;

  d3.select(this).attr("transform", function(d,i){
    return "translate(" + d + ")"
  });
  update();
}

function drag_spawnpoly(d,i) {
  // console.log("Start");
  if(d3.event.sourceEvent.shiftKey){
    // console.log("Drag spawn!");
    var copy = d.slice();
    polygon.splice(i,0,copy);
  }
  update();
}


var dragpoly = d3.behavior.drag()
        .on("drag", dragmove)
        .on("dragstart",drag_spawnpoly);

function click_to_remove(x, sourcearray, min){
  min = min | 0;
  x.on("click.to_rem", function(d,i){
    if (d3.event.defaultPrevented) return;
    if (sourcearray.length <= min) return;
    sourcearray.splice(i,1);
    update();
  });
}

// var svg = d3.select("body").append("svg")
//     .attr("width", width)
//     .attr("height", height)
var svg = d3.select("#c1");

var polygon_path = svg.append("g").selectAll("path.polygon");
var polygon_verts = svg.append("g").selectAll("circle.polygon_v");

var graph_path = svg.append("g").selectAll("path.graph");
var perp_path = svg.append("g").selectAll("path.perp");

update();

function check_simple(poly){
  // STUB: Should return true if polygon is simple
  // (doesn't cross itself)
  for (var i = 0; i < poly.length; i++) {
    var v1 = poly[i];
    var v2 = poly[(i+1)%poly.length];
    var j = 0;
    if(i==poly.length-1) j=1;
    for (; j < i-1; j++) {
      var v3 = poly[j];
      var v4 = poly[(j+1)%poly.length];
      var ires = intersect_edges(v1,v2,v3,v4);
      if(!(ires.a < 0 || ires.a > 1 || ires.b < 0 || ires.b > 1)){
        return false;
      }
    }
  };
  return true;
}

function check_clockwise(poly){
  var cum_ang = 0;
  for (var i = 0; i < poly.length; i++) {
    var v1 = poly[i];
    var v2 = poly[(i+1)%poly.length];
    var v3 = poly[(i+2)%poly.length];
    cum_ang += vector_angle(numeric.sub(v2,v1),numeric.sub(v3,v2));
  };
  // console.log(cum_ang);
  return cum_ang > 0;
}

function update(){
  // console.log(check_simple(polygon) , check_clockwise(polygon));
  polygon_is_good = check_simple(polygon) && check_clockwise(polygon);
  if(polygon_is_good){
    sskel = build_straight_skeleton(polygon);
    // perps = [];
    perps = findPerpendiculars(polygon, sskel);
  }else{
    sskel = null;
    perps = null;
  }

  redraw();
}

function get_shifted_pos(pt, time){
  if(!pt.pos) pt = sskel[0][pt];
  return move_pos(pt.pos, pt.vel, time);
}

var mousetime = 0;
document.addEventListener("mousemove",function(evt){
  mousetime = evt.pageX / width;
  redraw();
});

function redraw(){
  // var time = mousetime*100;
  polygon_path = polygon_path.data([polygon]);
  polygon_path.exit().remove();
  polygon_path.enter().append("path").attr("class","polygon");
  polygon_path.attr("d", poly_d_fn);

  if(polygon_is_good){
    polygon_path.attr("class", "polygon");
  }else{
    polygon_path.attr("class", "polygon bad");
  }

  if(sskel){
    graph_path = graph_path.data(sskel);
    perp_path = perp_path.data(perps);
  }else{
    graph_path = graph_path.data([]);
    perp_path = perp_path.data([]);
  }
  graph_path.exit().remove();
  graph_path.enter().append("path").attr("class","graph");
  graph_path.attr("d", function(d){
    return open_poly_d_fn(d.vertices.slice(1).concat(d.vertices.slice(0,1)));
  });
  perp_path.exit().remove();
  perp_path.enter().append("path").attr("class","perp");
  perp_path.attr("d", poly_d_fn);
  
  polygon_verts = polygon_verts.data(polygon);
  polygon_verts.exit().remove();
  polygon_verts.enter().append("circle");
  polygon_verts.attr("class","polygon_v")
      .attr("transform", function(d) { return "translate(" + d + ")"; })
      .attr("r", 6)
      .call(dragpoly).call(click_to_remove,polygon,3);
}

function poly_d_fn(d) {
  return "M" + d.join("L") + "Z";
}
function open_poly_d_fn(d) {
  return "M" + d.join("L");
}

</script>
</body>
</html>